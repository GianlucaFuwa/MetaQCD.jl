var documenterSearchIndex = {"docs":
[{"location":"parameters/#Full-Parameter-list-(-default):","page":"Parameters","title":"Full Parameter list (= default):","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"Base.@kwdef mutable struct PhysicalParameters\n    # gauge parameters\n    L::NTuple{4,Int64} = (4, 4, 4, 4)\n    beta::Float64 = 5.7\n    NC::Int64 = 3\n    gauge_action::String = \"wilson\"\n    numtherm::Int64 = 10\n    numsteps::Int64 = 100\n    inital::String = \"cold\"\n    update_method::Vector{String} = [\"HMC\"]\n    hb_maxit::Int64 = 10^5\n    numheatbath::Int64 = 4\n    metro_epsilon::Float64 = 0.1\n    metro_numhits::Int64 = 1\n    metro_target_acc::Float64 = 0.5\n    eo::Bool = true\n    or_algorithm::String = \"subgroups\"\n    numorelax::Int64 = 0\n    parity_update::Bool = false\nend\n\nBase.@kwdef mutable struct DynamicalFermionParameters\n    fermion_action::String = \"none\"\n    Nf::Union{Int,Vector{Int}} = 0\n    mass::Union{Float64,Vector{Float64}} = 0.0\n    wilson_r::Float64 = 1.0\n    wilson_csw::Float64 = 0.0\n    anti_periodic::Bool = true\n    cg_tol_action::Float64 = 1e-12\n    cg_tol_md::Float64 = 1e-14\n    cg_maxiters_action::Int64 = 1000\n    cg_maxiters_md::Int64 = 1000\n    rhmc_spectral_bound::NTuple{2,Float64} = (0.0, 64.0)\n    rhmc_recalc_spectral_bound::Bool = false\n    rhmc_order_action::Int64 = 15\n    rhmc_order_md::Int64 = 10\n    rhmc_prec_action::Int64 = 42\n    rhmc_prec_md::Int64 = 42\n    eo_precon::Bool = false\nend\n\nBase.@kwdef mutable struct BiasParameters\n    kind_of_bias::String = \"none\"\n    kind_of_cv::String = \"clover\"\n    numsmears_for_cv::Int64 = 4\n    rhostout_for_cv::Float64 = 0.125\n    is_static::Union{Bool,Vector{Bool}} = false\n    symmetric::Bool = false\n    stride::Int64 = 1\n    cvlims::NTuple{2,Float64} = (-7, 7)\n    biasfactor::Float64 = Inf\n    kinds_of_weights::Vector{String} = [\"tiwari\"]\n    usebiases::Vector{String} = [\"\"]\n    write_bias_every::Int64 = 1\n    # metadynamics specific\n    bin_width::Float64 = 1e-2\n    meta_weight::Float64 = 1e-3\n    penalty_weight::Float64 = 1000.0\n    # opes specific\n    barrier::Float64 = 0.0\n    sigma0::Float64 = 0.1\n    sigma_min::Float64 = 1e-6\n    fixed_sigma::Bool = false\n    no_Z::Bool = false\n    opes_epsilon::Float64 = 0.0\n    threshold::Float64 = 1.0\n    cutoff::Float64 = 0.0\n    # for parametric\n    bias_Q::Float64 = 0.0\n    bias_A::Float64 = 0.0\n    bias_Z::Float64 = 0.0\n    # tempering specific\n    tempering_enabled::Bool = false\n    numinstances::Int64 = 1\n    swap_every::Int64 = 1\n    non_metadynamics_updates::Int64 = 1\n    measure_on_all::Bool = false\nend\n\nBase.@kwdef mutable struct HMCParameters\n    hmc_trajectory::Float64 = 1\n    hmc_steps::Int64 = 10\n    hmc_friction::Float64 = 0.0\n    hmc_integrator::String = \"Leapfrog\"\n    hmc_rafriction::Float64 = 1.0\n    hmc_numsmear_gauge::Int64 = 0\n    hmc_numsmear_fermion::Int64 = 0\n    hmc_rhostout_gauge::Float64 = 0.0\n    hmc_rhostout_fermion::Float64 = 0.0\n    hmc_logging::Bool = true\nend\n\nBase.@kwdef mutable struct GradientFlowParameters\n    flow_integrator::String = \"euler\"\n    flow_num::Int64 = 1\n    flow_tf::Float64 = 0.1\n    flow_steps::Int64 = 10\n    flow_measure_every::Union{Int64,Vector{Int64}} = 1\nend\n\nBase.@kwdef mutable struct SystemParameters\n    float_type::String = \"float64\"\n    ensemble_dir::String = \"\"\n    log_to_console::Bool = true\n    verboselevel::Int64 = 1\n    save_config_format::String = \"\"\n    save_config_every::Int64 = 0\n    save_checkpoint_format::String = \"\"\n    save_checkpoint_every::Int64 = 0\n    load_config_fromfile::Bool = false\n    load_config_format::String = \"\"\n    load_config_path::String = \"\"\n    load_checkpoint_fromfile::Bool = false\n    load_checkpoint_format::String = \"jld2\"\n    load_checkpoint_path::String = \"\"\n    randomseed::Union{UInt64,Vector{UInt64}} = 0x0000000000000000\n    overwrite::Bool = false\nend\n\nBase.@kwdef mutable struct MeasurementParameters\n    measurement_method::Vector{Dict} = Dict[]\nend","category":"page"},{"location":"fermion_actions/","page":"-","title":"-","text":"<!– # Fermion Actions –> <!––> <!– Instead of explicitly creating the Dirac operator, one can also create the corresponding –> <!– fermion action, with similar syntax: –> <!––> <!– @docs --> <!-- WilsonFermionAction --> <!-- –> <!––> <!– @docs --> <!-- StaggeredFermionAction --> <!-- –> <!––> <!– @docs --> <!-- StaggeredEOPreFermionAction --> <!-- –>","category":"page"},{"location":"biased_sampling/#Biased-Sampling-Methods","page":"Biased Sampling Methods","title":"Biased Sampling Methods","text":"","category":"section"},{"location":"biased_sampling/","page":"Biased Sampling Methods","title":"Biased Sampling Methods","text":"Modules = [MetaQCD.BiasModule]\nOrder = [:function, :type]","category":"page"},{"location":"biased_sampling/#MetaQCD.BiasModule.calc_weights-Tuple{Nothing, Vararg{Any}}","page":"Biased Sampling Methods","title":"MetaQCD.BiasModule.calc_weights","text":"Weighting schemes based on the ones compared in \nhttps://pubs.acs.org/doi/pdf/10.1021/acs.jctc.9b00867\n\n\n\n\n\n","category":"method"},{"location":"biased_sampling/#MetaQCD.BiasModule.Bias","page":"Biased Sampling Methods","title":"MetaQCD.BiasModule.Bias","text":"Bias(p::ParameterSet, U::Gaugefield; instance=1)\n\nContainer that holds general parameters of bias enhanced sampling, like the kind of CV, its smearing and filenames/-pointers relevant to the bias. Also holds the specific kind of bias (Metadynamics, OPES or Parametric for now). \nThe instance keyword is used in case of PT-MetaD and multiple walkers to assign the correct usebias to each stream.\n\n\n\n\n\n","category":"type"},{"location":"biased_sampling/#MetaQCD.BiasModule.Metadynamics","page":"Biased Sampling Methods","title":"MetaQCD.BiasModule.Metadynamics","text":"Metadynamics(; symmetric=true, stride=1, cvlims=(-6, 6), biasfactor=Inf,\n              bin_width=0.1, weight=0.01, penalty_weight=1000)\nMetadynamics(p::ParameterSet; instance=1)\n\nCreate an instance of a Metadynamics bias using the inputs or the parameters given in p.\n\nSpecifiable parameters\n\nsymmetric::Bool = true - If true, the bias is built symmetrically by updating for both cv and -cv at every update-iteration \nstride::Int64 = 1 - Number of iterations between updates; must be >0 \ncvlims::NTuple{2, Float64} = (-6, 6) - Minimum and maximum of the explorable cv-space; must be ordered \nbiasfactor::Float64 = Inf - Biasfactor for well-tempered Metadynamics; must be >1 \nbin_width::Float64 = 0.1 - Width of bins in histogram; must be >0 \nweight::Float64 = 0.01 - (Starting) Height of added Gaussians; must be positive \npenalty_weight::Float64 = 1000 - Penalty when cv is outside of cvlims; must be positive \n\n\n\n\n\n\n","category":"type"},{"location":"biased_sampling/#MetaQCD.BiasModule.OPES","page":"Biased Sampling Methods","title":"MetaQCD.BiasModule.OPES","text":"OPES(; symmetric=true, stride=1, cvlims=(-6, 6), barrier=30,\n     biasfactor=Inf, σ₀=0.1, σ_min=1e-6, fixed_σ=true, opes_epsilon=0.0,\n     no_Z=false, threshold=1.0, cutoff=0.0)\nOPES(p::ParameterSet; instance=1)\n\nCreate an instance of a OPES bias using the parameters given in p.\n\nSpecifiable parameters\n\nsymmetric::Bool = true - If true, the bias is built symmetrically by updating for both cv and -cv at every update-iteration \nstride::Int64 = 1 - Number of iterations between updates; must be >0 \ncvlims::NTuple{2, Float64} = (-6, 6) - Minimum and maximum of the explorable cv-space; must be ordered \nbarrier::Float64 = 30 - Estimate of height of action barriers \nbiasfactor::Float64 = Inf - Biasfactor for well-tempered OPES; must be >1 \nσ₀::Float64 = 0.1 - (Starting) width of kernels; must be >0 \nσ_min::Float64 = 1e-6 - Minimum width of kernels; must be >0 \nfixed_σ::Bool = true - If true, width if kernels decreases iteratively \nϵ::Float64 = exp(-barrier/(1-1/biasfactor)) - Determines maximum height of bias; must be >0 \nno_Z::Bool = false - If false normalization factor Z is dynamically adjusted \nthreshold::Float64 = 1.0 - Threshold distance for kernel merging; must be >0 \ncutoff::Float64 = sqrt(2barrier/(1-1/biasfactor)) - Cutoff value for kernels; must be >0 \npenalty::Float64 = exp(-0.5cutoff²) - Penalty for being outside kernel cutoff; must be >0\n\n\n\n\n\n","category":"type"},{"location":"biased_sampling/#MetaQCD.BiasModule.Parametric","page":"Biased Sampling Methods","title":"MetaQCD.BiasModule.Parametric","text":"Parametric(cvlims, penalty_weight, Q, A, Z)\nParametric(p::ParameterSet; instance=1)\n\nCreate an instance of a static Parametric bias using the inputs or the parameters given in p.\n\nSpecifiable parameters\n\ncvlims::NTuple{2, Float64} = (-6, 6) - Minimum and maximum of the explorable cv-space; must be ordered \npenalty_weight::Float64 = 1000 - Penalty when cv is outside of cvlims; must be positive \nQ::Float64 = 0 - Quadratic term in the bias \nA::Float64 = 0 - Amplitude of the cosine term in the bias \nZ::Float64 = 0 - Frequency of the cosine term in the bias \n\n\n\n\n\n\n","category":"type"},{"location":"dirac/#Dirac-Operators","page":"Dirac Operators","title":"Dirac Operators","text":"","category":"section"},{"location":"dirac/","page":"Dirac Operators","title":"Dirac Operators","text":"Dirac operators are structs that hold a reference to the gauge background U, a temporary fermion field in case one wants to use the doubly flavoured Hermitian variant, the bare mass and a Boolean indicating whether there are antiperiodic boundary conditions in the time direction (yes, only periodic and antiperiodic BCs are supported so far).","category":"page"},{"location":"dirac/","page":"Dirac Operators","title":"Dirac Operators","text":"To create a Dirac operator, the constructors below are used. One thing to note is that dirac operators can be constructed using any Abstractfield and so the gauge background is always set to nothing on construction. In order to then add a gauge background you must use the dirac operator as a functor on a Gaugefield, like D_U = D_free(U). This does not overwrite the U in D_free but creates a new dirac operator, that references the same temporary fermion fields as the parent and does therefore not introduce any new allocations of fields.","category":"page"},{"location":"dirac/","page":"Dirac Operators","title":"Dirac Operators","text":"WilsonDiracOperator","category":"page"},{"location":"dirac/#MetaQCD.DiracOperators.WilsonDiracOperator","page":"Dirac Operators","title":"MetaQCD.DiracOperators.WilsonDiracOperator","text":"WilsonDiracOperator(::Abstractfield, mass; anti_periodic=true, r=1, csw=0)\nWilsonDiracOperator(D::WilsonDiracOperator, U::Gaugefield)\n\nCreate a free Wilson Dirac Operator with mass mass and Wilson parameter r. If anti_periodic is true the fermion fields are anti periodic in the time direction. If csw ≠ 0, a clover term is included.  This object cannot be applied to a fermion vector, since it lacks a gauge background. A Wilson Dirac operator with gauge background is created by applying it to a Gaugefield U like D_gauge = D_free(U)\n\nType Parameters:\n\nB: Backend (CPU / CUDA / ROCm)\nT: Floating point precision\nTF: Type of the Fermionfield used to store intermediate results when using the        Hermitian version of the operator\nTG: Type of the underlying Gaugefield\nC: Boolean declaring whether the operator is clover improved or not\n\n\n\n\n\n","category":"type"},{"location":"dirac/","page":"Dirac Operators","title":"Dirac Operators","text":"StaggeredDiracOperator","category":"page"},{"location":"dirac/#MetaQCD.DiracOperators.StaggeredDiracOperator","page":"Dirac Operators","title":"MetaQCD.DiracOperators.StaggeredDiracOperator","text":"StaggeredDiracOperator(::Abstractfield, mass; anti_periodic=true)\nStaggeredDiracOperator(D::StaggeredDiracOperator, U::Gaugefield)\n\nCreate a free Staggered Dirac Operator with mass mass. If anti_periodic is true the fermion fields are anti periodic in the time direction. This object cannot be applied to a fermion vector, since it lacks a gauge background. A Staggered Dirac operator with gauge background is created by applying it to a Gaugefield U like D_gauge = D_free(U)\n\nType Parameters:\n\nB: Backend (CPU / CUDA / ROCm)\nT: Floating point precision\nTF: Type of the Fermionfield used to store intermediate results when using the        Hermitian version of the operator\nTG: Type of the underlying Gaugefield\n\n\n\n\n\n","category":"type"},{"location":"dirac/","page":"Dirac Operators","title":"Dirac Operators","text":"StaggeredEOPreDiracOperator","category":"page"},{"location":"dirac/#MetaQCD.DiracOperators.StaggeredEOPreDiracOperator","page":"Dirac Operators","title":"MetaQCD.DiracOperators.StaggeredEOPreDiracOperator","text":"StaggeredEOPreDiracOperator(::Abstractfield, mass; anti_periodic=true)\nStaggeredEOPreDiracOperator(\n    D::Union{StaggeredDiracOperator,StaggeredEOPreDiracOperator},\n    U::Gaugefield\n)\n\nCreate a free even-odd preconditioned Staggered Dirac Operator with mass mass. If anti_periodic is true the fermion fields are anti periodic in the time direction. This object cannot be applied to a fermion vector, since it lacks a gauge background. A Staggered Dirac operator with gauge background is created by applying it to a Gaugefield U like D_gauge = D_free(U)\n\nType Parameters:\n\nB: Backend (CPU / CUDA / ROCm)\nT: Floating point precision\nTF: Type of the Fermionfield used to store intermediate results when using the        Hermitian version of the operator\nTG: Type of the underlying Gaugefield\n\n\n\n\n\n","category":"type"},{"location":"viz/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"We include the ability to visualize your data. For that, you have pass the the directory under \"ensembles\" that contains your measurements, creating a MetaMeasuremnts object holding all the measurements in Dict where the keys are symbols denoting the observable.","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"ens = \"my_ensemble\"\nmeasurements = MetaMeasurements(ens)","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"Now we can plot a timeseries of any observables at flow time tf measured on the ensemble via the timeseries method:","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"timeseries(measurements, :myobservable, tf=0)","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"For hadron correlators there is a special function hadroncorrelator that plots the mean values of all time slices (without statistical uncertainties). Just specify the hadron whose correlator you want to see:","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"hadroncorrelator(measurements, :pion; logscale=true, calc_meff=false, tf=0.0)","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"You can also create a holder of a bias potential and plot it. MetaQCD.jl creates the bias files with an extension that gives their type (.metad or .opes), but if you changed the extension you have to provide the bias type as a symbol under the kwarg which:","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"bias = MetaBias(myfile, which=:mytype)\nbiaspotential(bias)","category":"page"},{"location":"observables/","page":"-","title":"-","text":"<!– # Measure Observables –>","category":"page"},{"location":"utils/#Utility-Functions","page":"Utility Functions","title":"Utility Functions","text":"","category":"section"},{"location":"utils/","page":"Utility Functions","title":"Utility Functions","text":"Modules = [MetaQCD.Utils]\nOrder = [:function, :type]","category":"page"},{"location":"utils/#MetaQCD.Utils.cdot-Union{Tuple{N}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{N}, Complex{T}, 1, N}, StaticArraysCore.SArray{Tuple{N}, Complex{T}, 1, N}}} where {T, N}","page":"Utility Functions","title":"MetaQCD.Utils.cdot","text":"cdot(a, b)\n\nReturn the complex dot product of a and b\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.cinv-Union{Tuple{StaticArraysCore.SArray{Tuple{2, 2}, Complex{T}, 2, 4}}, Tuple{T}} where T","page":"Utility Functions","title":"MetaQCD.Utils.cinv","text":"cinv(M)\n\nCalculate the inverse of the complex matrix M.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.ckron-Union{Tuple{N}, Tuple{M}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{M}, Complex{T}, 1, M}, StaticArraysCore.SArray{Tuple{N}, Complex{T}, 1, N}}} where {T, M, N}","page":"Utility Functions","title":"MetaQCD.Utils.ckron","text":"ckron(a, b)\nckron(A, B)\n\nReturn the complex Kronecker(outer) product of vectors a and b, i.e. a ⊗ b†, or of two matrices A and B, i.e. A ⊗ B.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.cmvmul-Union{Tuple{NM}, Tuple{M}, Tuple{N}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{M, N}, Complex{T}, 2, NM}, StaticArraysCore.SArray{Tuple{N}, Complex{T}, 1, N}}} where {T, N, M, NM}","page":"Utility Functions","title":"MetaQCD.Utils.cmvmul","text":"cmvmul(A, x)\n\nReturn the matrix-vector product of A and x\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.cmvmul_block-Union{Tuple{N2}, Tuple{NN}, Tuple{N}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{N, N}, Complex{T}, 2, NN}, StaticArraysCore.SArray{Tuple{N, N}, Complex{T}, 2, NN}, StaticArraysCore.SArray{Tuple{N2}, Complex{T}, 1, N2}}} where {T, N, NN, N2}","page":"Utility Functions","title":"MetaQCD.Utils.cmvmul_block","text":"cmvmul_block(A₊, A₋, x)\n\nReturn the matrix-vector product of the block diagonal matrix containing A₊ and A₋ and the vector x        \n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.cmvmul_color-Union{Tuple{N2}, Tuple{M}, Tuple{N}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{N, N}, Complex{T}, 2, N2}, StaticArraysCore.SArray{Tuple{M}, Complex{T}, 1, M}}} where {T, N, M, N2}","page":"Utility Functions","title":"MetaQCD.Utils.cmvmul_color","text":"cmvmul_color(A, x)\n\nReturn the matrix-vector product of A and x, where A only acts on the color structure of x.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.cmvmul_d-Union{Tuple{NM}, Tuple{M}, Tuple{N}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{M, N}, Complex{T}, 2, NM}, StaticArraysCore.SArray{Tuple{N}, Complex{T}, 1, N}}} where {T, N, M, NM}","page":"Utility Functions","title":"MetaQCD.Utils.cmvmul_d","text":"cmvmul_d(A, x)\n\nReturn the matrix-vector product of the adjoint of A and x\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.cmvmul_d_color-Union{Tuple{N2}, Tuple{M}, Tuple{N}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{N, N}, Complex{T}, 2, N2}, StaticArraysCore.SArray{Tuple{M}, Complex{T}, 1, M}}} where {T, N, M, N2}","page":"Utility Functions","title":"MetaQCD.Utils.cmvmul_d_color","text":"cmvmul_d_color(A, x)\n\nReturn the matrix-vector product of A† and x, where A† only acts on the colo structure of x.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.cmvmul_spin_proj-Union{Tuple{is_adjoint}, Tuple{ρ}, Tuple{N2}, Tuple{M}, Tuple{N}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{N, N}, Complex{T}, 2, N2}, StaticArraysCore.SArray{Tuple{M}, Complex{T}, 1, M}, Val{ρ}}, Tuple{StaticArraysCore.SArray{Tuple{N, N}, Complex{T}, 2, N2}, StaticArraysCore.SArray{Tuple{M}, Complex{T}, 1, M}, Val{ρ}, Val{is_adjoint}}} where {T, N, M, N2, ρ, is_adjoint}","page":"Utility Functions","title":"MetaQCD.Utils.cmvmul_spin_proj","text":"cmvmul_spin_proj(A, x, ::Val{ρ}, ::Val{is_adjoint}=Val(false))\n\nReturn A * (1 ± γᵨ) * x where γᵨ is the ρ-th Euclidean gamma matrix in the Chiral basis. x is assumed to be a 4xN component complex vector. The third argument is ρ wrapped in a Val and must be within the range [-4,4]. Its sign determines the sign in front of the γᵨ matrix. If is_adjoint is true, A† is used instead of A.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.cnorm2-Union{Tuple{StaticArraysCore.SArray{Tuple{N, N}, Complex{T}, 2, N²}}, Tuple{T}, Tuple{N²}, Tuple{N}} where {N, N², T}","page":"Utility Functions","title":"MetaQCD.Utils.cnorm2","text":"cnorm2(A::SMatrix{N,N,Complex{T},N²}) where {N,N²,T}\n\nCalculate the 2-norm of the complex NxN matrix M\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.cvmmul-Union{Tuple{NM}, Tuple{M}, Tuple{N}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{N}, Complex{T}, 1, N}, StaticArraysCore.SArray{Tuple{M, N}, Complex{T}, 2, NM}}} where {T, N, M, NM}","page":"Utility Functions","title":"MetaQCD.Utils.cvmmul","text":"cvmmul(x, A)\n\nReturn the vector-matrix product of x† and A.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.cvmmul_color-Union{Tuple{N2}, Tuple{M}, Tuple{N}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{M}, Complex{T}, 1, M}, StaticArraysCore.SArray{Tuple{N, N}, Complex{T}, 2, N2}}} where {T, N, M, N2}","page":"Utility Functions","title":"MetaQCD.Utils.cvmmul_color","text":"cvmmul_color(x, A)\n\nReturn the matrix-vector product of x† and A, where A only acts on the color structure of x†.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.cvmmul_d-Union{Tuple{NM}, Tuple{M}, Tuple{N}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{N}, Complex{T}, 1, N}, StaticArraysCore.SArray{Tuple{M, N}, Complex{T}, 2, NM}}} where {T, N, M, NM}","page":"Utility Functions","title":"MetaQCD.Utils.cvmmul_d","text":"cvmmul_d(x, A)\n\nReturn the vector-matrix product of x and the adjoint of A. x is implicitly assumed to be a column vector and therefore the adjoint of x is used\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.cvmmul_d_color-Union{Tuple{N2}, Tuple{M}, Tuple{N}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{M}, Complex{T}, 1, M}, StaticArraysCore.SArray{Tuple{N, N}, Complex{T}, 2, N2}}} where {T, N, M, N2}","page":"Utility Functions","title":"MetaQCD.Utils.cvmmul_d_color","text":"cvmmul_d_color(x, A)\n\nReturn the matrix-vector product of x† and A†, where A† only acts on the color structure of x†.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.exp_iQ-Union{Tuple{StaticArraysCore.SArray{Tuple{3, 3}, Complex{T}, 2, 9}}, Tuple{T}} where T","page":"Utility Functions","title":"MetaQCD.Utils.exp_iQ","text":"exp_iQ(Q::SU{3,9,T}) where {T}\nexp_iQ(e::exp_iQ_su3{T}) where {T}\n\nCompute the exponential of a traceless Hermitian 3x3 matrix Q or return the exp_iQ field of the exp_iQ_su3{T}-object e. \nFrom Morningstar & Peardon (2008) arXiv:hep-lat/0311018v1\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.exp_iQ_coeffs-Union{Tuple{StaticArraysCore.SArray{Tuple{3, 3}, Complex{T}, 2, 9}}, Tuple{T}} where T","page":"Utility Functions","title":"MetaQCD.Utils.exp_iQ_coeffs","text":"exp_iQ_coeffs(Q::SU{3,9,T}) where {T}\n\nReturn a exp_iQ_su3 object that contains the exponential of Q and all parameters obtained in the Cayley-Hamilton algorithm that are needed for Stout force recursion.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.gaussian_TA_mat-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Utility Functions","title":"MetaQCD.Utils.gaussian_TA_mat","text":"gaussianTAmat(::Type{T}) where {T}\n\nGenerate a normally distributed traceless anti-Hermitian 3x3 matrix with precision T.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.gen_SU2_matrix-Union{Tuple{T}, Tuple{Any, Type{T}}} where T","page":"Utility Functions","title":"MetaQCD.Utils.gen_SU2_matrix","text":"genSU2matrix(ϵ, ::Type{T}) where {T}\n\nGenerate a Matrix X ∈ SU(2) with precision T near the identity with spread ϵ. \nFrom Gattringer C. & Lang C.B. (Springer, Berlin Heidelberg 2010)\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.gen_SU3_matrix-Union{Tuple{T}, Tuple{Any, Type{T}}} where T","page":"Utility Functions","title":"MetaQCD.Utils.gen_SU3_matrix","text":"genSU3matrix(ϵ, ::Type{T}) where {T}\n\nGenerate a Matrix X ∈ SU(3) with precision T near the identity with spread ϵ. \nFrom Gattringer C. & Lang C.B. (Springer, Berlin Heidelberg 2010)\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.kenney_laub-Union{Tuple{StaticArraysCore.SArray{Tuple{3, 3}, Complex{T}, 2, 9}}, Tuple{T}} where T","page":"Utility Functions","title":"MetaQCD.Utils.kenney_laub","text":"kenney_laub(M::SMatrix{3,3,Complex{T},9}) where {T}\n\nCompute the SU(3) matrix closest to M using the Kenney-Laub algorithm.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.move-Tuple{CartesianIndex{4}, Any, Any, Any}","page":"Utility Functions","title":"MetaQCD.Utils.move","text":"move(s::SiteCoords, μ, steps, lim)\n\nMove a site s in the direction μ by steps steps with periodic boundary conditions. The maximum extent of the lattice in the direction μ is lim.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.multr-Union{Tuple{T}, Tuple{N²}, Tuple{N}, Tuple{StaticArraysCore.SArray{Tuple{N, N}, Complex{T}, 2, N²}, StaticArraysCore.SArray{Tuple{N, N}, Complex{T}, 2, N²}}} where {N, N², T}","page":"Utility Functions","title":"MetaQCD.Utils.multr","text":"multr(A::SMatrix{N,N,Complex{T},N²}, B::SMatrix{N,N,Complex{T},N²}) where {N,N²,T}\n\nCalculate the trace of the product of two complex NxN matrices A and B of precision T.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.rand_SU3-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Utility Functions","title":"MetaQCD.Utils.rand_SU3","text":"rand_SU3(::Type{T}) where {T}\n\nGenerate a random Matrix X ∈ SU(3) with precision T. \n\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.spin_proj-Union{Tuple{ρ}, Tuple{M}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{M}, Complex{T}, 1, M}, Val{ρ}}} where {T, M, ρ}","page":"Utility Functions","title":"MetaQCD.Utils.spin_proj","text":"spin_proj(x, ::Val{ρ})\n\nReturn (1 ± γᵨ) * x where γᵨ is the ρ-th Euclidean gamma matrix in the Chiral basis. and x is a 4xN component complex vector. The second argument is ρ wrapped in a Val and must be within the range [-4,4]. Its sign determines the sign in front of the γᵨ matrix.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.spintrace-Union{Tuple{M}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{M}, Complex{T}, 1, M}, StaticArraysCore.SArray{Tuple{M}, Complex{T}, 1, M}}} where {T, M}","page":"Utility Functions","title":"MetaQCD.Utils.spintrace","text":"spintrace(a, b)\n\nReturn the complex Kronecker(outer) product of vectors a and b, summing over dirac indices, i.e. ∑ ᵨ aᵨ ⊗ bᵨ†\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.spintrace_σμν-Union{Tuple{ν}, Tuple{μ}, Tuple{MM}, Tuple{M}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{M, M}, Complex{T}, 2, MM}, StaticArraysCore.SArray{Tuple{M, M}, Complex{T}, 2, MM}, Val{μ}, Val{ν}}} where {T, M, MM, μ, ν}","page":"Utility Functions","title":"MetaQCD.Utils.spintrace_σμν","text":"spintrace_σμν(A, B, ::Val{μ}, ::Val{ν})\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.switch_sides-Union{Tuple{T}, Tuple{CartesianIndex{4}, Vararg{T, 5}}} where T<:Integer","page":"Utility Functions","title":"MetaQCD.Utils.switch_sides","text":"switch_sides(site::CartesianIndex, NX, NY, NZ, NT, NV)\n\nReturn the cartesian index equivalent to site but with opposite parity. E.g., switch_sides((1, 1, 1, 1), 4, 4, 4, 4, 256) = (1, 1, 1, 3) and reverse\n\n\n\n\n\n","category":"method"},{"location":"utils/#MetaQCD.Utils.σμν_spin_mul-Union{Tuple{ν}, Tuple{μ}, Tuple{M}, Tuple{T}, Tuple{StaticArraysCore.SArray{Tuple{M}, Complex{T}, 1, M}, Val{μ}, Val{ν}}} where {T, M, μ, ν}","page":"Utility Functions","title":"MetaQCD.Utils.σμν_spin_mul","text":"σμν_spin_mul(x, ::Val{μ}, ::Val{ν})\n\nReturn σμν * x where σμν = i/2 * [γμ, γν] with the gamma matrices in the Chiral basis and x is a 4xN component complex vector. The latter two arguments are μ and ν wrapped in a Val and must be within the range [1,4] with μ < ν\n\n\n\n\n\n","category":"method"},{"location":"gaugefields/#Creating-Fields-on-the-lattice","page":"Creating Gaugefields","title":"Creating Fields on the lattice","text":"","category":"section"},{"location":"gaugefields/","page":"Creating Gaugefields","title":"Creating Gaugefields","text":"You can create a 4-dimensional SU(3) gauge field by specifying the backend, floating point precision, gauge action, dimensions and coupling parameter beta:","category":"page"},{"location":"gaugefields/","page":"Creating Gaugefields","title":"Creating Gaugefields","text":"backend = CPU\nprec = Float64\naction = WilsonGaugeAction\nNs = Nt = 12\nbeta = 6.0\nU = Gaugefield{backend,prec,action}(Ns, Ns, Ns, Nt, beta) # all links are set to 0","category":"page"},{"location":"gaugefields/","page":"Creating Gaugefields","title":"Creating Gaugefields","text":"and set the initial conditions with identity_gauges!(U) (cold) or random_gauges!(U) (hot).","category":"page"},{"location":"gaugefields/","page":"Creating Gaugefields","title":"Creating Gaugefields","text":"Gaugefields, Colorfields and Expfields are structs that contain a main Array U, which is a 5-dimensional array of statically sized 3x3 complex matrices, i.e., SMatrix objects from StaticArrays.jl (where arrays are stored as Tuples under the hood).","category":"page"},{"location":"gaugefields/","page":"Creating Gaugefields","title":"Creating Gaugefields","text":"The fact that the elements are statically sized immutable arrays means that, for one, there are no allocations when performing linear algebra operations with them and secondly that we always just override the matrices in the arrays instead of mutating them. This yields enormous benefits in terms of less headaches during development and lets us define custom linear algebra routines for SMatrices and SVectors.","category":"page"},{"location":"gaugefields/","page":"Creating Gaugefields","title":"Creating Gaugefields","text":"The different backends are handled by Kernelabstractions.jl.","category":"page"},{"location":"gaugefields/","page":"Creating Gaugefields","title":"Creating Gaugefields","text":"We might use more memory efficient storage schemes for SU(3) or su(3) elements in the future.","category":"page"},{"location":"gaugefields/","page":"Creating Gaugefields","title":"Creating Gaugefields","text":"Fermion fields or spinors or whatever you want to call them are stored in 4-dimensional  arrays of n_color * n_dirac complex valued SVectors. The reason for chosing 4 instead of 5 dimensions is that this enabled us to write routines that take care of all dirac components at the same time, which should be more efficient.","category":"page"},{"location":"gaugefields/","page":"Creating Gaugefields","title":"Creating Gaugefields","text":"When using even-odd preconditioned dirac operators, the fermion fields get wrapped in a struct called EvenOdd such that we can overload all functions on that type. Our convention is to define the fields on the even sites. While we haven't tested whether the following is actually more performant, we map all even sites to the first half of the array to have contiguous memory accesses. The function eo_site does exactly this mapping.","category":"page"},{"location":"gaugefields/","page":"Creating Gaugefields","title":"Creating Gaugefields","text":"Fermionfields are created in the same way as Gaugefields with the gauge action type parameter being replaced by the number of Dirac indices. For Fermionfields we have the ones! and gaussian_pseudofermions! methods to init them.","category":"page"},{"location":"gaugefields/","page":"Creating Gaugefields","title":"Creating Gaugefields","text":"Gaugefield","category":"page"},{"location":"gaugefields/#MetaQCD.Fields.Gaugefield","page":"Creating Gaugefields","title":"MetaQCD.Fields.Gaugefield","text":"Gaugefield{BACKEND,T,GA}(NX, NY, NZ, NT, β)\nGaugefield(U::Gaugefield)\nGaugefield(parameters::ParameterSet)\n\nCreates a Gaugefield on BACKEND, i.e. an array of link-variables (SU3 matrices with T precision) of size 4 × NX × NY × NZ × NT with coupling parameter β and gauge action GA or a zero-initialized copy of U\n\nSupported backends\n\nCPU \nCUDABackend \nROCBackend\n\nSupported gauge actions\n\nWilsonGaugeAction \nSymanzikTreeGaugeAction (Lüscher-Weisz) \nIwasakiGaugeAction \nDBW2GaugeAction\n\n\n\n\n\n","category":"type"},{"location":"gaugefields/","page":"Creating Gaugefields","title":"Creating Gaugefields","text":"Fermionfield","category":"page"},{"location":"gaugefields/#MetaQCD.Fields.Fermionfield","page":"Creating Gaugefields","title":"MetaQCD.Fields.Fermionfield","text":"Fermionfield{BACKEND,T,ND}(NX, NY, NZ, NT)\nFermionfield(ψ::Fermionfield)\nFermionfield(f::Abstractfield, staggered)\n\nCreates a Fermionfield on BACKEND, i.e. an array of link-variables (NC×ND complex vectors with T precision) of size NX × NY × NZ × NT or a zero-initialized copy of ψ. If staggered=true, the number of Dirac degrees of freedom (ND) is reduced to 1 instead of 4.\n\nSupported backends\n\nCPU \nCUDABackend \nROCBackend\n\n\n\n\n\n","category":"type"},{"location":"gaugefields/","page":"Creating Gaugefields","title":"Creating Gaugefields","text":"Colorfield","category":"page"},{"location":"gaugefields/#MetaQCD.Fields.Colorfield","page":"Creating Gaugefields","title":"MetaQCD.Fields.Colorfield","text":"Colorfield{BACKEND,T}(NX, NY, NZ, NT)\nColorfield(u::Abstractfield)\n\nCreates a Colorfield on BACKEND, i.e. an array of 3-by-3 T-precision matrices of size 4 × NX × NY × NZ × NT or a zero-initialized Colorfield of the same size as u\n\nSupported backends\n\nCPU \nCUDABackend \nROCBackend\n\n\n\n\n\n","category":"type"},{"location":"gaugefields/","page":"Creating Gaugefields","title":"Creating Gaugefields","text":"Expfield","category":"page"},{"location":"gaugefields/#MetaQCD.Fields.Expfield","page":"Creating Gaugefields","title":"MetaQCD.Fields.Expfield","text":"Expfield{BACKEND,T}(NX, NY, NZ, NT)\nExpfield(u::Abstractfield)\n\nCreates a Expfield on BACKEND, i.e. an array of T-precison exp_iQ_su3 objects of size 4 × NX × NY × NZ × NT or of the same size as u. The objects hold the Q-matrices and all the exponential parameters needed for stout-force recursion\n\nSupported backends\n\nCPU \nCUDABackend \nROCBackend\n\n\n\n\n\n","category":"type"},{"location":"updates/#Updating-a-Gaugefield","page":"Updating a Gaugefield","title":"Updating a Gaugefield","text":"","category":"section"},{"location":"updates/","page":"Updating a Gaugefield","title":"Updating a Gaugefield","text":"To update a Gaugefield simply use the update! function that takes 2 positional arguments and however many keyword arguments specific to the update algorithm.  The first positional is the actual update algorithm update_alg and the second is the Gaugefield U.","category":"page"},{"location":"updates/","page":"Updating a Gaugefield","title":"Updating a Gaugefield","text":"U = Gaugefield(...)\nrandom_gauges!(U)\n\nMAXIT = 100\nnumHB = 1\nor_alg = MeatQCD.Updates.Subgroups\nnumOR = 4\nupdate_alg = MeatQCD.Updates.Heatbath(U, MAXIT, numHB, or_alg, numOR)\n\nupdate!(update_alg, U; ...) ","category":"page"},{"location":"updates/#Supported-Update-Algorithms","page":"Updating a Gaugefield","title":"Supported Update Algorithms","text":"","category":"section"},{"location":"updates/","page":"Updating a Gaugefield","title":"Updating a Gaugefield","text":"HMC","category":"page"},{"location":"updates/#MetaQCD.Updates.HMC","page":"Updating a Gaugefield","title":"MetaQCD.Updates.HMC","text":"HMC(\n    U,\n    integrator,\n    trajectory,\n    steps,\n    friction = 0,\n    numsmear = 0,\n    ρ_stout = 0;\n    hmc_logging = true,\n    fermion_action = nothing,\n    heavy_flavours = 0,\n    bias_enabled = false,\n    logdir = \"\",\n)\n\nCreate an HMC object, that can be used as an update algorithm.\n\nArguments\n\nU: The gauge field on which the update is performed.\nintegrator: The integrator used to evolve the field.\ntrajectory: The length of the HMC trajectory.\nsteps: The number of integrator steps within the trajectory.\nfriction: Friction factor in the GHMC algorithm. Has to be in the range [0, 1].\nnumsmear: Number of Stout smearing steps applied to the gauge action.\nρ_stout: Step length of the Stout smearing applied to the gauge action.\nhmc_logging: If true, creates a logfile in logdir containing information\n\non the trajectories, unless logdir = \"\"\n\nfermion_action: An AbstratFermionAction to initialize the appropriate fermion fields\nheavy_flavours: The number of non-degenerate heavy flavours, again to initialize the\n\nright number of fermion fields\n\nbias_enabled: If true, additional fields are initialized that are needed for Stout\n\nforce recursion when using a bias.\n\nSupported Integrators\n\nLeapfrog\nOMF2\nOMF2Slow\nOMF4\nOMF4Slow\n\nSupported Fermion Actions\n\nWilsonFermionAction\nStaggeredFermionAction\nStaggeredEOPreFermionAction\n\n\n\n\n\n","category":"type"},{"location":"updates/","page":"Updating a Gaugefield","title":"Updating a Gaugefield","text":"Metropolis","category":"page"},{"location":"updates/#MetaQCD.Updates.Metropolis","page":"Updating a Gaugefield","title":"MetaQCD.Updates.Metropolis","text":"Metropolis(U::Gaugefield{B,T,A,GA}, eo, ϵ, numhits, target_acc, or_alg, numorelax) where {B,T,A,GA}\n\nCreate a Metropolis object.\n\nArguments\n\nU::Gaugefield{B,T,A,GA}: Gauge field object.\neo: Even-odd preconditioning.\nϵ: Step size for the update.\nnumhits: Number of Metropolis hits.\ntarget_acc: Target acceptance rate.\nor_alg: Overrelaxation algorithm.\nnumorelax: Number of overrelaxation sweeps.\n\nReturns\n\nA Metropolis object with the specified parameters. The gauge action GA of the field U determines the iterator used. For the plaquette or Wilson action it uses a Checkerboard iterator and for rectangular actions it partitions the lattice into four sublattices.\n\n\n\n\n\n","category":"type"},{"location":"updates/","page":"Updating a Gaugefield","title":"Updating a Gaugefield","text":"Heatbath","category":"page"},{"location":"updates/#MetaQCD.Updates.Heatbath","page":"Updating a Gaugefield","title":"MetaQCD.Updates.Heatbath","text":"Heatbath(U::Gaugefield{B,T,A,GA}, MAXIT, numheatbath, or_alg, numorelax) where {B,T,A,GA}\n\nCreate a Heatbath` object.\n\nArguments\n\nU: The gauge field on which the update is performed.\nMAXIT: The maximum iteration count in the Heatbath update.\nnumheatbath: The number of Heatbath sweeps.\nor_alg: The overrelaxation algorithm used.\nnumorelax: The number of overrelaxation sweeps.\n\nReturns\n\nA Heatbath object with the specified parameters. The gauge action GA of the field U determines the iterator used. For the plaquette or Wilson action it uses a Checkerboard iterator and for rectangular actions it partitions the lattice into four sublattices.\n\n\n\n\n\n","category":"type"},{"location":"updates/","page":"Updating a Gaugefield","title":"Updating a Gaugefield","text":"Overrelaxation","category":"page"},{"location":"updates/#MetaQCD.Updates.Overrelaxation","page":"Updating a Gaugefield","title":"MetaQCD.Updates.Overrelaxation","text":"Overrelaxation(algorithm)\n\nCreate an Overrelaxation object, that can be used within a Metropolis or Heatbath update step.\n\nSupported Algorithms\n\n\"subgroups\": Cabibbo-Marinari SU(2) subgroup embedding scheme\n\"kenney_laub\": Kenney-Laub projection onto SU(3)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"If you just want to perform a simulation with some parameters, then","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Set parameters using one of the templates in template folder\nFrom shell, do:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia --threads=auto metaqcd_sim.jl parameters.toml","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"or","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Start Julia (with project):","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia --threads=auto --project=/path/to/dir/containing/MetaQCD.jl","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Import MetaQCD package:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using MetaQCD","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Begin Simulation with prepared parameter file \"parameters.toml\":","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"run_sim(\"parameters.toml\")","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"To use another backend, just append its name to the command:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia --threads=auto metaqcd_sim.jl parameters.toml cuda","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Logs, measurements and the lot are all written to files in the ensembles directory under the specified directory name. If no directory name is provided, one is generated based on time the simulation was started at.","category":"page"},{"location":"usage/#Build-a-Bias","page":"Usage","title":"Build a Bias","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Set parameters using the \"parameters_build.toml\" example in template folder\nFrom shell, do:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia --threads=auto metaqcd_build.jl parameters.toml","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"or","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Start Julia (with project):","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia --threads=auto --project=/path/to/dir/containing/MetaQCD.jl","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Import MetaQCD package:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using MetaQCD","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Begin build with prepared parameter file \"parameters.toml\":","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"build_bias(\"parameters.toml\")","category":"page"},{"location":"usage/#Visualization","page":"Usage","title":"Visualization","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"We include the ability to visualize your data. For that, you just have to pass the directory where your ensemble lives:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"pkg> measurements = MetaMeasurements(\"my_ensemble\")\npkg> timeseries(measurements, :my_observable)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"You can also create a holder of a bias potential and plot it. MetaQCD.jl creates the bias files with an extension that gives their type (.metad or .opes), but if you changed the extension you have to provide the bias type as a symbol under the kwarg which:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"bias = MetaBias(myfile, which=:mytype)\nbiaspotential(bias)","category":"page"},{"location":"#MetaQCD.jl","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl","text":"","category":"section"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"Inspired by the LatticeQCD.jl package by Akio Tomiya et al.","category":"page"},{"location":"#Features","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"Features","text":"","category":"section"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"Simulations of 4D-SU(3) Yang-Mills (Pure Gauge) theory\nSimulations of full lattice QCD with arbitrary number of flavours (Staggered, Wilson-Clover)\nMetadynamics\nPT-MetaD\nSeveral update algorithms (HMC, Metropolis, Heatbath, Overrelaxation)\nSeveral symplectic integrators for HMC (Leapfrog, OMF2, OMF4)\nGradient flow with variable integrators (Euler, RK2, RK3, RK3W7)\nImproved Gauge actions (Symanzik tree, Iwasaki, DBW2)\nImproved Topological charge definitions (clover, rectangle clover-improved)\nWilson fermions with and without clover improvement\nStaggered fermions\nEven-odd preconditioner\nRHMC to simulate odd number of flavours\nSupport for CUDA and ROCm(not tested) backends","category":"page"},{"location":"#Installation","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"Installation","text":"","category":"section"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"First make sure you have a Julia version 1.9.x or 1.10.x installed. You can use juliaup for that or just install the release from the Julia website.","category":"page"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"The package is not in the general registry. So you will have to either","category":"page"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"Add the package to your Julia environment (not recommended) via:","category":"page"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"julia> ] add https://github.com/GianlucaFuwa/MetaQCD.jl","category":"page"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"or (recommended)","category":"page"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"Clone this repository onto your machine.\nOpen Julia in the directory which you cloned the repo into, with the project specific environment. This can either be done by starting Julia with the command line argument \"–project\" or by activating the environment within an opened Julia instance via the package manager:","category":"page"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"using Pkg\nPkg.activate(\".\")","category":"page"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"Or you can switch to package manager mode by typing \"]\" and then do","category":"page"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"pkg> activate .","category":"page"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"Instantiate the project to install all the dependencies using the package manager:","category":"page"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"Pkg.instantiate()","category":"page"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"or","category":"page"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"pkg> instantiate","category":"page"},{"location":"","page":"MetaQCD.jl: Metadynamics in Lattice QCD","title":"MetaQCD.jl: Metadynamics in Lattice QCD","text":"If you want to use a GPU, make sure you not only have CUDA.jl (v4.4.2) or AMDGPU.jl installed, but also a fairly recent version of the CUDA Toolkit or ROCm.","category":"page"}]
}
